#!/usr/bin/env python3
"""
Simple CLI Minesweeper template.

Features:
- Create a board with width, height, and number of mines
- Reveal cells (with flood fill for zeros)
- Flag/unflag cells
- Simple text-based display
- Basic win/lose detection

Usage:
    python3 minesweeper.py            # starts an interactive game with defaults
    python3 minesweeper.py 10 8 12   # width=10, height=8, mines=12
Controls (in-game):
    r x y   -> reveal cell at column x, row y (0-based)
    f x y   -> toggle flag at column x, row y
    q       -> quit
"""

import random
import sys
from collections import deque
from typing import List, Tuple

Cell = Tuple[bool, bool, int]  # (is_mine, is_revealed, neighbor_count) - flags tracked separately

class Board:
    def __init__(self, width: int = 9, height: int = 9, mines: int = 10):
        if mines >= width * height:
            raise ValueError("Too many mines for the board size")
        self.w = width
        self.h = height
        self.mines = mines
        self.flags = [[False] * width for _ in range(height)]
        self._init_board()

    def _init_board(self):
        # Create empty board
        self._mine_grid = [[False] * self.w for _ in range(self.h)]
        self._revealed = [[False] * self.w for _ in range(self.h)]
        # Place mines randomly
        all_positions = [(x, y) for y in range(self.h) for x in range(self.w)]
        random.shuffle(all_positions)
        for x, y in all_positions[: self.mines]:
            self._mine_grid[y][x] = True
        # Precompute neighbor counts
        self._neighbor_counts = [[0] * self.w for _ in range(self.h)]
        for y in range(self.h):
            for x in range(self.w):
                if self._mine_grid[y][x]:
                    self._neighbor_counts[y][x] = -1
                else:
                    self._neighbor_counts[y][x] = sum(
                        1
                        for nx, ny in self._neighbors(x, y)
                        if self._mine_grid[ny][nx]
                    )

    def _in_bounds(self, x: int, y: int) -> bool:
        return 0 <= x < self.w and 0 <= y < self.h

    def _neighbors(self, x: int, y: int):
        for dy in (-1, 0, 1):
            for dx in (-1, 0, 1):
                if dx == 0 and dy == 0:
                    continue
                nx, ny = x + dx, y + dy
                if self._in_bounds(nx, ny):
                    yield nx, ny

    def reveal(self, x: int, y: int) -> bool:
        """
        Reveal the cell at (x,y). Returns True if move is safe, False if a mine was revealed.
        """
        if not self._in_bounds(x, y) or self._revealed[y][x] or self.flags[y][x]:
            return True  # ignore invalid or already revealed or flagged
        if self._mine_grid[y][x]:
            self._revealed[y][x] = True
            return False  # hit mine -> lose
        # Flood fill for zero neighbors
        q = deque()
        q.append((x, y))
        while q:
            cx, cy = q.popleft()
            if self._revealed[cy][cx]:
                continue
            self._revealed[cy][cx] = True
            if self._neighbor_counts[cy][cx] == 0:
                for nx, ny in self._neighbors(cx, cy):
                    if not self._revealed[ny][nx] and not self._mine_grid[ny][nx]:
                        q.append((nx, ny))
        return True

    def toggle_flag(self, x: int, y: int):
        if not self._in_bounds(x, y) or self._revealed[y][x]:
            return
        self.flags[y][x] = not self.flags[y][x]

    def is_won(self) -> bool:
        # Won when all non-mine cells are revealed
        for y in range(self.h):
            for x in range(self.w):
                if not self._mine_grid[y][x] and not self._revealed[y][x]:
                    return False
        return True

    def display(self, reveal_all: bool = False) -> str:
        # Build a simple text representation
        lines = []
        header = "   " + " ".join(f"{x:2}" for x in range(self.w))
        lines.append(header)
        for y in range(self.h):
            row_chars = []
            for x in range(self.w):
                if reveal_all and self._mine_grid[y][x]:
                    ch = "*"
                elif self._revealed[y][x]:
                    cnt = self._neighbor_counts[y][x]
                    ch = "." if cnt == 0 else str(cnt)
                elif self.flags[y][x]:
                    ch = "F"
                else:
                    ch = "#"
                row_chars.append(f"{ch:2}")
            lines.append(f"{y:2} " + " ".join(row_chars))
        return "\n".join(lines)

    # Helper getters for potential tests
    def is_mine(self, x: int, y: int) -> bool:
        return self._mine_grid[y][x]

    def neighbor_count(self, x: int, y: int) -> int:
        return self._neighbor_counts[y][x]

def parse_args(argv):
    if len(argv) >= 4:
        w = int(argv[1])
        h = int(argv[2])
        m = int(argv[3])
        return w, h, m
    return 9, 9, 10

def main():
    w, h, m = parse_args(sys.argv)
    board = Board(w, h, m)
    lost = False
    print("Minesweeper (CLI). Coordinates are x y (0-based).")
    while True:
        print(board.display())
        if lost:
            print("You hit a mine! Game over.")
            print(board.display(reveal_all=True))
            break
        if board.is_won():
            print("Congratulations, you won!")
            print(board.display(reveal_all=True))
            break
        cmd = input("Enter command (r x y | f x y | q): ").strip().split()
        if not cmd:
            continue
        if cmd[0] == "q":
            print("Quitting.")
            break
        if cmd[0] in ("r", "f") and len(cmd) >= 3:
            try:
                x = int(cmd[1])
                y = int(cmd[2])
            except ValueError:
                print("Invalid coordinates; use integers.")
                continue
            if not (0 <= x < w and 0 <= y < h):
                print("Coordinates out of range.")
                continue
            if cmd[0] == "f":
                board.toggle_flag(x, y)
            else:
                ok = board.reveal(x, y)
                if not ok:
                    lost = True
        else:
            print("Unknown command. Use r x y, f x y, or q.")

if __name__ == "__main__":
    main()
